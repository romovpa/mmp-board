%%% DOCUMENT
\documentclass[a4paper]{article}
% article options:
%   - a4paper, letterpaper
%   - twocolumn
%   - landscape
%   - 10p, 11pt, 12pt
%   - draft

%%% PACKAGES
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc} 
\usepackage[pdftex,unicode]{hyperref}
\usepackage[english,russian]{babel}   % language

\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{color}
\usepackage{pb-diagram}
%\usepackage{movie15}

% style
\usepackage{indentfirst}
\usepackage{fullpage}

%%% TITLE
\title{Искусственный интеллект для игры ``Коньки''}
\author{Петр Ромов, группа 317}
\date{\today}

%%% CONTENT
\begin{document}

\begin{titlepage}
\begin{center}
    Московский государственный университет имени М. В. Ломоносова

    \bigskip
    \includegraphics[width=50mm]{msu.eps}

    \bigskip
    Факультет Вычислительной Математики и Кибернетики\\
    Кафедра Математических Методов Прогнозирования\\[10mm]

    \bigskip
    \bigskip

    \textsf{\large\bfseries
        Отчет по практикуму\\[10mm]
	   Искусственный интеллект для игры ``Коньки''
    }\\[10mm]

    \begin{flushright}
        \parbox{0.5\textwidth}{
            Выполнил: \\
		  студент 3 курса 317 группы\\
            \emph{Ромов Петр Алексеевич}\\[5mm]
        }
    \end{flushright}

    \vspace{\fill}
    Москва, 2011
\end{center}
\end{titlepage}

В качестве задания практикума требуется написать искуственный интеллект для игры ``Коньки'', т.е. программу, которая получает на вход позицию в игре и делает ход. 

\section{Описание игры}

Игра происходит на доске размера $8 \times 8$. На доске изначально находятся фишки двух цветов: красные и синие, некоторые клетки доски помечены цифрами (1 или 2). Начальный счет 0--0. Игра ведется по следующим правилам:
\begin{enumerate}
\item Игроки ходят поочередно: первый игрок --- красными фишками, второй --- синими. За один ход игрок обязан передвинуть одну фишку.
\item Фишки ходят как шахматный конь.
\item Ходить можно на любую клетку, не занятую своей фишкой.
	\begin{itemize}
	\item Если клетка была помечена цифрой, метка удаляется, сделавшему ход прибавляется соответствующее цифре число очков.
	\item Если клетка была занята фишкой соперника, то фишка соперника ``съедается'', а сделавшему ход прибавляется 1 очко.
	\end{itemize}
\item Если фишки одного из игроков располагаются на одной горизонтали/вертикали, то этому игроку прибавляется 3 очка, игра заканчивается. При этом, если после некоторого хода у обоих игроков фишки располагаются на одной горизонтали/вертикали, то обоим игрокам прибавляется 3 очка.
\item Выигрывает игрок, набравший наибольшее число очков. При равенстве очков --- ничья.
\item Если за 30 ходов игра не закончилась, засчитывается ничья (независимо от текущего счета).
\end{enumerate}

\section{Алгоритм и реализация}

Поиск наилучшего хода осуществляется при помощи альфа-бета алгоритма. Для увеличения количества подрезок дерева перебора использовались следующие техники:
\begin{itemize}
\item предварительный перебор с нулевым окном (алгоритм NegaScout)
\item перебор ходов из каждой позиции в порядке убывания их "важности"
\end{itemize}

\subsection{Генерация ходов}
Ходы из одной позиции разделяются на три класса:
\begin{enumerate}
\item {\itshape завершающие игру}: ходы, после которых фишки одного из игроков становятся в ряд;
\item {\itshape изменяющие состав поля}: ходы, при которых фишка ``съедает'' метку или фишку противника;
\item {\itshape простые}: ходы фишки на пустую клетку поля.
\end{enumerate}
Алгоритм перебирает последовательно от ходов первого класса к третьему. 

\subsection{Функция оценки позиции}
В общем виде, выбранную функцию оценки позиции можно записать в виде:
$$\text{\tt value} = \alpha (\text{\tt score}_\text{player} - \text{\tt score}_\text{opponent}) + \beta (\text{\tt straightness}_\text{player} - \text{\tt straightness}_\text{opponent}),$$
где $\text{\tt score}_p$ --- количество очков у игрока $p$, $\text{\tt straightness}_p$ --- некоторая величина, принимающая тем меньшее значение, чем сильнее фишки игрока $p$ разбросаны по доске.

Величину $\text{\tt straightness}$ можно вычислять различными способами. В приведенной реализации за $\text{\tt straightness}$ взято максимальное число фишек игрока, находящихся в одном ряду или строке.

Параметры $\alpha$ и $\beta$ определяют значимость двух оценок. Эксперименты показали, что небольшие изменения этих параметров не влияют на решения, принимаемые программой. В приведенной реализации $\alpha=1,\; \beta=1$ (выбраны экспериментально).

Выигрышная позиция оценивается числом $\text{\tt INF} - \text{\tt depth}$, где $\text{\tt INF}$ --- некоторое достаточно большое целое число, $\text{\tt depth}$ --- номер полухода относительно изначально данной программе позиции игры. Таким образом, при прочих равных, алгоритм будет стремиться победить за меньшее число ходов.

Проигрышная позиция оценивается числом $- \text{\tt INF} + (\text{\tt score}_\text{player} - \text{\tt score}_\text{opponent})$. Если позиция такова, что при правильной игре обоих игров, текущий должен проиграть, текущий будет стремиться сократить разницу между числом очков у противника и у себя. Если противник сделает ``плохой'' ход, то у игрока будет больше шансов на победу, т.к. в рассматриваемой игре исход решает соотношение числа очков.

\subsection{Распределение времени}

Одной из наиболее сложных и интересных проблем является распределение выделенного игроку времени на вычисление отдельных ходов. При одной и той же глубине перебора алгоритм может отработать, потратив незначительно времени, или не успеть завершиться до конца партии --- зависит от количества ходов на одну позицию, количества подрезок (на это в свою очередь сильно влияет порядок ходов из одной позиции).

Для того чтобы уложиться во время, можно в ходе перебора изменять глубину --- увеличивать, если в распоряжении достаточно много времени, уменьшать, если время подходит к концу. Чтобы подойти к задаче более формально, поставим вопрос: находясь в некотором узле дерева перебора, сколько понадобится алгоритму времени, чтобы перебрать оставшуюся часть? Сколько понадобится алгоритму времени, если дальнейший перебор будет вестись глубже (или наоборот --- поверхностней)?

Реализованный алгоритм фиксирует глубину перебора исходя из:
\begin{itemize}
\item количества фишек игрока на поле;
\item номера хода (например, программа поддерживает ``режим дебюта'', когда первые несколько ходов расчитываются с большей глубиной);
\item оставшегося времени (например, если остается достаточно мало; времени, программа переходит в ``режим цейтнота'', глубина перебора уменьшается);
\end{itemize}

Cледующий метод решения поставленой задачи был опробован, однако не принес ожидаемого улучшения: 
\begin{itemize}
\item Будем считать, что время работы перебора из некоторой вершины на глубину $h$ --- случайная величина $T_h$, имеющая матожидание $\mathsf{E}T_h$.
\item По ходу алгоритма можно оценивать значение $\mathsf{E}T_h$ как выборочное среднее $\bar T_h$ по прецедентам, которые возникают в процессе перебора (время перебора поддеревьев).
\item Предполагая $T_h \approx \mathsf{E}T_h$ можем посчитать приближенное значение времени до завершения перебора (в данный момент находимся в вершине дерева перебора на грубине $d$): 
$$T_\text{remains} \approx \bar{T}_h R_d + \bar{T}_{h+1} R_{d-1} + \cdots + \bar{T}_{h+d} R_{1},$$
где $R_d$ --- число необработанных вершин дерева перебора на глубине $d$, $h$ --- глубина терминальных вершин (листьев) относительно текущей. Используя это же выражение можно подобрать наилучшее $h$ и продолжить перебор с нужной глубиной.
\item Метод плохо показал себя на практике, давал сильно завышенные значения времени, что делало распределение времени неэффективным. Это происходит из-за того, что в выражении для $T_\text{remains}$ не учитываются возможные подрезания текущего дерева перебора. Можно поразмышлять над более точной моделью времени работы перебора.
\item Еще одним улучшением метода может быть введение некоторого параметрического семейства распределений на $T_h$, оцениванием параметра по прецедентам --- обработанным частям дерева перебора с замеренным временем. 
\end{itemize}

%\section{Примеры работы алгоритма}

%\begin{figure}[h]
%	\begin{multicols}{1}
		%\hfill
		%\boxed{ \includegraphics[width=50mm]{graph/sample_A_4_score_6-4.eps} }
		%\hfill
		%\caption{Ход 4. Счет 6--4.}
		%\label{sample1}
%		\hfill
%		\boxed{\includegraphics[width=50mm]{graph/situation.eps}}
%		\hfill
%		\caption{Пример игровой ситуации.}
%		\label{sample2}
%	\end{multicols}
%\end{figure}

\section{Выводы}

Предложенная игра сильно отличается от шахмат. Специфика правил игры ``Коньки'' такова, что игра может быть завершена за достаточно небольшое число ходов. За счет этого типичный перебор достигает достаточно много терминальных (за счет конца игры) позиций. Функция оценки позиции вовсе не интуитивна. Это наталкивает на мысть о том, что нужно увеличивать глубину перебора, количество отсечений.

Число отсечений в альфа-бета алгоритме зависит от порядка, в котором перебираются ходы. Экспериментально, упорядочивание ходов начиная от "активных" заканчивая ходами "бездействия" приводит к сильному увеличению числа подрезок.

Увеличение глубины перебора может привести к тому, что программа не будет укладываться в отведенное ей время. Выбор между быстродействием перебора и его глубиной является интересной задачей, над которой можно подумать на досуге.

\subsection{Что хотелось бы сделать}

В процессе написания алгоритма возникало много идей по его улучшению, некоторые части алгоритма можно было реализовать различными способами. Для того чтобы сделать программу, которая играет наилучшим образом, нужно уметь оценивать качество работы алгоритма с фиксированными параметрами, имея в наличии лишь свои наработки. Это можно было сделать путем запуска программ с различными параметрами на большом наборе игровых полей.

\section{Руководство пользователя}

Исходный код программы написан на языке C, содержит поясняющие комментарии. В файле {\tt options.h} содержатся все возможные настройки алгоритма в виде макроопределений языка C.

Для сборки программы нужно использовать утилиту {\tt make}.

Скомпилированная программа считывает из файла {\tt matrix.txt} текущую позицию в игре, вычисляет наилучший ход, перезаписывает файл {\tt matrix.txt} новой позицией игры.


\begin{thebibliography}{1}
	\bibitem{dj}

	Дьяконов, A. Г. 
	\emph{Анализ данных, обучение по прецедентам, логические игры, системы WEKA, RapidMiner и MatLab (практикум на ЭВМ кафедры математических методов прогнозирования). }
	МАКСПресс, 2010

\end{thebibliography}

\end{document}
